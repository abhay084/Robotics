def subway():
 {
  "cells": [
   {
    "cell_type": "code",
    "execution_count": null,
    "id": "3daad5a5",
    "metadata": {},
    "outputs": [],
    "source": [
     "import cv2\n",
     "import mediapipe as mp\n",
     "import pyautogui\n",
     "mp_drawing = mp.solutions.drawing_utils\n",
     "mp_holistic = mp.solutions.holistic\n",
     "mp_hands = mp.solutions.hands\n",
     "cap = cv2.VideoCapture(0)\n",
     "tipIds = [4, 8, 12, 16, 20]\n",
     "game_started = 1\n",
     "charac_pos = [0,1,0]\n",
     "index_pos = 1\n",
     "fixedx = None\n",
     "fixedy = None\n",
     "rec = None\n",
     "with mp_hands.Hands(min_detection_confidence=0.5, min_tracking_confidence=0.5) as hands:\n",
     "    with mp_holistic.Holistic(min_detection_confidence=0.5,min_tracking_confidence=0.5) as holistic:\n",
     "        while True:\n",
     "            success, frame = cap.read()\n",
     "            frame = cv2.flip(frame, 1)\n",
     "            frame = cv2.resize(frame, (440,330))\n",
     "            height, width, channel = frame.shape\n",
     "            img = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n",
     "            results_holistic = holistic.process(img)\n",
     "            results_hands = hands.process(img)\n",
     "            img = cv2.cvtColor(img,cv2.COLOR_RGB2BGR)\n",
     "            width_hf = int(width/2)\n",
     "            height_hf = int(height/2)\n",
     "            # Extracting Shoulder Landmarks\n",
     "            if results_holistic.pose_landmarks:\n",
     "                right_x = int(results_holistic.pose_landmarks.landmark[mp_holistic.PoseLandmark.LEFT_SHOULDER].x * width)-7\n",
     "                right_y = int(results_holistic.pose_landmarks.landmark[mp_holistic.PoseLandmark.LEFT_SHOULDER].y * height)\n",
     "                # cv2.circle(img, (right_x, right_y), 5, (0, 0, 0), 2)\n",
     "                left_x = int(results_holistic.pose_landmarks.landmark[mp_holistic.PoseLandmark.RIGHT_SHOULDER].x * width)+7\n",
     "                left_y = int(results_holistic.pose_landmarks.landmark[mp_holistic.PoseLandmark.RIGHT_SHOULDER].y * height)\n",
     "                # cv2.circle(img, (left_x, left_y), 5, (0, 0, 0), 2)\n",
     "                # cv2.line(img, (left_x,left_y), (right_x,right_y), (255, 0, 255), 2)\n",
     "                mid_x = left_x + int(abs(right_x - left_x) / 2)\n",
     "                mid_y = int(abs(right_y + left_y) / 2)\n",
     "                # cv2.circle(img, (mid_x, mid_y), 2, (255, 255, 0), 2)\n",
     "                if rec != None:\n",
     "                    # Sideways movement command\n",
     "                    if right_x < width_hf and index_pos > 0 and charac_pos[index_pos-1] == 0:\n",
     "                        charac_pos[index_pos] = 0\n",
     "                        charac_pos[index_pos-1] = 1\n",
     "                        pyautogui.press('left')\n",
     "                        index_pos -= 1\n",
     "                        print(\"Left key\")\n",
     "                        print(charac_pos)\n",
     "                    if left_x > width_hf and index_pos < 2 and charac_pos[index_pos+1] == 0:\n",
     "                        print(\"Right key\")\n",
     "                        charac_pos[index_pos] = 0\n",
     "                        charac_pos[index_pos+1] = 1\n",
     "                        pyautogui.press('right')\n",
     "                        index_pos += 1\n",
     "                        print(charac_pos)\n",
     "                    if right_x > width_hf and left_x < width_hf and index_pos == 0:\n",
     "                        charac_pos[index_pos] = 0\n",
     "                        charac_pos[index_pos +1] = 1\n",
     "                        index_pos += 1\n",
     "                        pyautogui.press('right')\n",
     "                        print(charac_pos)\n",
     "                        print('left to center')\n",
     "                    if right_x > width_hf and left_x < width_hf and index_pos == 2:\n",
     "                        charac_pos[index_pos] = 0\n",
     "                        charac_pos[index_pos -1] = 1\n",
     "                        index_pos -= 1\n",
     "                        pyautogui.press('left')\n",
     "                        print('right to center')\n",
     "                        print(charac_pos)\n",
     "\n",
     "            hand_cor_list_right = []\n",
     "            hand_cor_list_left = []\n",
     "            hand_type1 = None\n",
     "            hand_type2 = None\n",
     "            fingers_right = []\n",
     "            fingers_left = []\n",
     "            # Detection of both hands and extracting both hand landmarks\n",
     "            try:\n",
     "                hand_type1 = results_hands.multi_handedness[0].classification[0].label\n",
     "                hand_type2 = results_hands.multi_handedness[1].classification[0].label\n",
     "                for hand_no, hand_landmarks in enumerate(results_hands.multi_hand_landmarks):\n",
     "                    if hand_no == 0:\n",
     "                        if hand_type1 == 'Left':\n",
     "                            for id, lm in enumerate(hand_landmarks.landmark):\n",
     "                                cx, cy = int(lm.x * width), int(lm.y * height)\n",
     "                                # cv2.circle(img, (cx,cy),2, (100,255,100),2)\n",
     "                                hand_cor_list_left.append([id,cx,cy])\n",
     "                        elif hand_type1 == 'Right':\n",
     "                            for id, lm in enumerate(hand_landmarks.landmark):\n",
     "                                cx, cy = int(lm.x * width), int(lm.y * height)\n",
     "                                # cv2.circle(img, (cx,cy),2, (100,255,100),2)\n",
     "                                hand_cor_list_right.append([id,cx,cy])\n",
     "                    if hand_no == 1:\n",
     "                        if hand_type2 == 'Left':\n",
     "                            for id, lm in enumerate(hand_landmarks.landmark):\n",
     "                                cx, cy = int(lm.x * width), int(lm.y * height)\n",
     "                                # cv2.circle(img, (cx,cy),2, (100,255,100),2)\n",
     "                                hand_cor_list_left.append([id,cx,cy])\n",
     "                        elif hand_type2 == 'Right':\n",
     "                            for id, lm in enumerate(hand_landmarks.landmark):\n",
     "                                cx, cy = int(lm.x * width), int(lm.y * height)\n",
     "                                # cv2.circle(img, (cx,cy),2, (100,255,100),2)\n",
     "                                hand_cor_list_right.append([id,cx,cy])\n",
     "                if hand_cor_list_right != []:\n",
     "                    # Right Hand Thumb open Detection\n",
     "                    if hand_cor_list_right[tipIds[0]][1] < hand_cor_list_right[tipIds[0] - 1][1]:\n",
     "                        fingers_right.append(1)\n",
     "                    else:\n",
     "                        fingers_right.append(0)\n",
     "\n",
     "                    # Right Hand 4 Fingers open Detection\n",
     "                    for id in range(1, 5):\n",
     "                        if hand_cor_list_right[tipIds[id]][2] < hand_cor_list_right[tipIds[id] - 2][2]:\n",
     "                            fingers_right.append(1)\n",
     "                        else:\n",
     "                            fingers_right.append(0)\n",
     "                    totalFingers_right = fingers_right.count(1)\n",
     "\n",
     "                if hand_cor_list_left != []:\n",
     "                    # Left hand Thumb open detection\n",
     "                    if hand_cor_list_left[tipIds[0]][1] > hand_cor_list_left[tipIds[0] - 1][1]:\n",
     "                        fingers_left.append(1)\n",
     "                    else:\n",
     "                        fingers_left.append(0)\n",
     "\n",
     "                    # Left Hand 4 Fingers open Detection\n",
     "                    for id in range(1, 5):\n",
     "                        if hand_cor_list_left[tipIds[id]][2] < hand_cor_list_left[tipIds[id] - 2][2]:\n",
     "                            fingers_left.append(1)\n",
     "                        else:\n",
     "                            fingers_left.append(0)\n",
     "                    totalFingers_left = fingers_left.count(1)\n",
     "            except:\n",
     "                pass\n",
     "            # Command to Start the game\n",
     "            if fingers_right.count(1) == 2 and fingers_left.count(1) == 2 and fingers_right[1] == 1 and fingers_right[2] == 1 and fingers_left[1] == 1 and fingers_left[1] == 1:\n",
     "                fixedx = left_x + int(abs(right_x - left_x) / 2)\n",
     "                fixedy = int(abs(right_y + left_y) / 2)\n",
     "                rec = 35\n",
     "                pyautogui.press('space')\n",
     "\n",
     "            # Up and Down command\n",
     "            if fixedy is not None:\n",
     "                if (mid_y- fixedy) <= -24:\n",
     "                    pyautogui.press('up')\n",
     "                    print('jump')\n",
     "                elif (mid_y - fixedy) >= 40:\n",
     "                    pyautogui.press('down')\n",
     "                    print('down')\n",
     "            center_arrow = 10\n",
     "            cv2.circle(img,(width_hf,height_hf),2,(0,255,255),2)\n",
     "            cv2.line(img,(width_hf,height_hf -center_arrow),(width_hf,height_hf+center_arrow),(0,255,0),2)\n",
     "            cv2.line(img,(width_hf -center_arrow,height_hf),(width_hf+center_arrow,height_hf),(0,255,0),2)\n",
     "            # Lines to be crossed to detect up and down movement\n",
     "            # if rec is not None:\n",
     "            #     cv2.line(img, (0, fixedy), (width, fixedy), (0, 0, 0), 2)\n",
     "            #     cv2.line(img, (0, fixedy - 24), (width, fixedy - 24), (0, 0, 0), 2)\n",
     "            #     cv2.line(img, (0, fixedy + rec), (width, fixedy + rec), (0, 0, 0), 2)\n",
     "\n",
     "            cv2.imshow('Subway Surfers',img)\n",
     "            cv2.waitKey(1)"
    ]
   }
  ],
  "metadata": {
   "kernelspec": {
    "display_name": "Python 3",
    "language": "python",
    "name": "python3"
   },
   "language_info": {
    "codemirror_mode": {
     "name": "ipython",
     "version": 3
    },
    "file_extension": ".py",
    "mimetype": "text/x-python",
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
    "version": "3.8.8"
   }
  },
  "nbformat": 4,
  "nbformat_minor": 5
 }
